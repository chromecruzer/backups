#![deny(clippy::all)]
#![allow(unused_imports)]

use napi::bindgen_prelude::*;
use tokio::fs;

#[macro_use]
extern crate napi_derive;


#[napi]
pub async fn async_plus_100(p: Promise<u32>) -> Result<u32> {
    let v = p.await?;
    Ok(v + 100)
}
#[napi]
async fn read_file_async(path: String) -> Result<Buffer> {
    // Read the file asynchronously using fs::read, no need to await the Result itself
    let content = fs::read(path).await.map_err(|e| {
        Error::new(
            Status::GenericFailure,
            format!("failed to read file, {}", e),
        )
    })?;

    // Convert the Vec<u8> into a Buffer to return
    Ok(content.into())
}











// #![deny(clippy::all)]

// use napi::bindgen_prelude::Buffer;
// use std::fs;
// use std::fs::File;
// use std::io::Read;
// use std::path::Path;

// #[macro_use]
// extern crate napi_derive;

// #[napi]
// pub fn read_file(path: String) -> Result<String, napi::Error> {
//     let content = fs::read_to_string(path).map_err(|e| napi::Error::from_reason(e.to_string()))?;
//     Ok(content)
// }

// #[napi]
// pub fn read_file_as_buffer(path: String) -> Result<Buffer, napi::Error> {
//     println!("Received path: {}", path); // Log the input path

//     // Spawn a thread to handle file reading
//     let handle = std::thread::spawn(move || {
//         let path = Path::new(&path);
//         println!("Converted path to Path type");

//         // Attempt to open the file and handle any errors
//         let mut file = match File::open(&path) {
//             Ok(f) => {
//                 println!("Successfully opened file at path: {:?}", path);
//                 f
//             }
//             Err(e) => {
//                 println!("Error opening file: {}", e);
//                 return Err(napi::Error::from_reason(e.to_string()));
//             }
//         };

//         let mut buffer = Vec::new();
//         println!("Initialized empty buffer");

//         // Attempt to read the file into the buffer
//         match file.read_to_end(&mut buffer) {
//             Ok(size) => {
//                 println!("Successfully read file to buffer, size: {} bytes", size);
//             }
//             Err(e) => {
//                 println!("Error reading file to buffer: {}", e);
//                 return Err(napi::Error::from_reason(e.to_string()));
//             }
//         };

//         println!("Converting Vec<u8> to napi Buffer v2.0");
//         // Convert Vec<u8> to Buffer
//         Ok(Buffer::from(buffer))
//     });

//     // Wait for the thread to finish and return the result
//     match handle.join() {
//         Ok(result) => result, // Return the result from the thread
//         Err(e) => {
//             println!("Error joining thread: {:?}", e);
//             Err(napi::Error::from_reason("Thread join error".to_string()))
//         }
//     }
// }








index.d.ts
/////////////////////
/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

import Buffer from "buffer"

export declare function asyncPlus100(p: Promise<number>): Promise<number>
export declare function readFileAsync(path: string): Promise<Buffer>



/////////////////// cargo.toml
[package]
edition = "2021"
name = "my-plugin_rustacean"
version = "0.0.0"

[lib]
crate-type = ["cdylib"]

[dependencies]
# Default enable napi4 feature, see https://nodejs.org/api/n-api.html#node-api-version-matrix
napi = { version = "2.12.2", default-features = false, features = ["napi4", "tokio_rt"] }
tokio = { version = "1.42.0", features = ["fs", "full"] }
csv = "1.1"
napi-derive = "2.16.13"
futures = "0.3"

[build-dependencies]
napi-build = "2.0.1"

[profile.release]
lto = true
strip = "symbols"
